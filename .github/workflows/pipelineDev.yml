name: Pipeline de Seguridad 

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  analisis-seguridad:
    runs-on: ubuntu-latest
    steps:
      # 1. Obtener el código completo (incluyendo historial para Gitleaks)
      - name: Clonar repositorio
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      # ------------------------------------------------------------------
      # FASE 1: DETECCIÓN DE SECRETOS EN EL CÓDIGO (GITLEAKS)
      # ------------------------------------------------------------------
      - name: Gitleaks - Buscando tokens y contraseñas hardcodeadas
        uses: zricethezav/gitleaks-action@v1.6.0
        # Si encuentra algo con alta confianza, el pipeline fallará automáticamente

      # ------------------------------------------------------------------
      # FASE 2: ANÁLISIS DE DEPENDENCIAS (SNYK)
      # ------------------------------------------------------------------
      - name: Instalar dependencias del sistema y Snyk
        run: |
          sudo apt-get update
          sudo apt-get install -y libjpeg-dev zlib1g-dev  # Necesario para Pillow
          pip install -r requirements.txt                  # Instalar dependencias de Python
          npm install -g snyk                              # Cliente de Snyk

      - name: Snyk - Escaneo de vulnerabilidades en librerías
        run: snyk test --severity-threshold=high
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        # El umbral high hace que el pipeline falle si hay vulnerabilidades críticas/altas

      - name: Generar reporte HTML de Snyk (incluso si falla)
        if: always()
        run: |
          npm install -g snyk-to-html@1.4.0
          snyk test --severity-threshold=high --json > snyk-report.json || true
          snyk-to-html -i snyk-report.json -o snyk-report.html || true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

      # ------------------------------------------------------------------
      # FASE 3: ANÁLISIS ESTÁTICO DE CALIDAD Y SEGURIDAD (SONARCLOUD)
      # ------------------------------------------------------------------
      - name: SonarCloud - Análisis de código fuente
        uses: sonarsource/sonarqube-scan-action@master
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          args: >
            -Dsonar.host.url=https://sonarcloud.io
            -Dsonar.organization=aaronqarcias
            -Dsonar.projectKey=crazyserk
            -Dsonar.sources=.
            -Dsonar.python.version=3.9

      # ------------------------------------------------------------------
      # FASE 4: ANÁLISIS DINÁMICO CON OWASP ZAP (DAST)
      # ------------------------------------------------------------------
      - name:  Configurar Python para script de ZAP
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Instalar librería para conectar con ZAP API
        run: pip install python-owasp-zap-v2.4

      - name: Construir y lanzar PyGoat con Docker
        run: |
          # Usamos el Dockerfile que ya viene en el repositorio
          docker build -t pygoat-app .
          # Ejecutamos en modo detached y en red del host para que sea accesible
          docker run -d --name pygoat-instance --network host pygoat-app
          echo "⏳ Damos tiempo a que la aplicación arranque..."
          sleep 30

      - name: Iniciar ZAP en modo daemon
        run: |
          docker run -d --name zap-daemon --network host \
            -v $(pwd):/zap/wrk:rw \
            zaproxy/zap-stable \
            zap.sh -daemon -host 0.0.0.0 -port 8080 \
            -config api.key=${{ secrets.ZAP_API_KEY }}
          echo "Esperando a que ZAP termine de arrancar..."
          sleep 30

      - name: Ejecutar escaneo activo con ZAP
        run: python zap_scan.py
        env:
          ZAP_API_KEY: ${{ secrets.ZAP_API_KEY }}
        # El script zap_scan.py debe estar en la raíz y apuntar a http://localhost:8000

      # ------------------------------------------------------------------
      # FASE 5: SUBIR REPORTES COMO ARTEFACTOS (SIEMPRE, AUNQUE FALLE)
      # ------------------------------------------------------------------
      - name: Guardar reporte de Snyk
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: snyk-report
          path: snyk-report.html
          if-no-files-found: warn

      - name: Guardar reporte de ZAP
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: zap-report
          path: zap-report.html
          if-no-files-found: warn

      # ------------------------------------------------------------------
      # FASE 6: CONSTRUIR IMAGEN FINAL (SOLO SI TODO HA IDO BIEN)
      # ------------------------------------------------------------------
      - name: Construir imagen Docker lista para producción
        if: success()
        run: |
          # Re-etiquetamos la imagen que ya construimos antes
          docker tag pygoat-app pygoat:final
          echo "Imagen 'pygoat:final' generada correctamente"
          docker images | grep pygoat
